#ifndef __PEDASM_DEF_H__
#define __PEDASM_DEF_H__

#define BIT_MODE_16		0
#define BIT_MODE_32		1
#define BIT_MODE_64		2
typedef BYTE BIT_MODE;

#define SEG_REGS_MAX	6
#define CREGS_MAX		9
#define DREGS_MAX		8

/* Maximum instruction size, including prefixes */
#define MAX_INST_LENGTH		15
#define MAX_OPRNDS_COUNT	4
#define MAX_PREFIX_COUNT	4

/* Wait instruction byte code. */
#define OPCODE_WAIT	0x9b
/* Lea instruction byte code. */
#define OPCODE_LEA	0x8d
/* NOP/XCHG instruction byte code. */
#define OPCODE_NOP	0x90
/* ARPL/MOVSXD instruction byte code. */
#define OPCODE_ARPL	0x63
/*
* Minimal MODR/M value of divided instructions.
* It's 0xc0, two MSBs set, which indicates a general purpose register is used too.
*/
#define MODRM_PIVOT_VAL	0xC0

enum PFX_CODE : BYTE
{
	PF_NONE		= 0x00,
	PF_OP_SIZE	= 0x66,
	PF_AD_SIZE	= 0x67,
	PF_SEG_CS	= 0x2E,
	PF_SEG_DS	= 0x3E,
	PF_SEG_ES	= 0x26,
	PF_SEG_FS	= 0x64,
	PF_SEG_GS	= 0x65,
	PF_SEG_SS	= 0x36,
	PF_LOCK		= 0xF0,
	PF_REP		= 0xF3,
	PF_REPN		= 0xF2,
	PF_REX		= 0x40,
	PF_VEX2B	= 0xC5,
	PF_VEX3B	= 0xC4,
	PF_XOP		= 0x8F
};
#define CHECK_PF_REX(x)	(((x) & 0xF0) == PFX_CODE::PF_REX)


#define REGI_NONE	0xFF
#define REQ_SIB		0xFE

#define EX_GPR_BASE		  8
#define REGS64_BASE		  0
#define REGS32_BASE		 16
#define REGS16_BASE		 32
#define REGS8_BASE		 48
#define REGS8_REX_BASE	 64
#define SREGS_BASE		 68
#define FPUREGS_BASE	 75
#define MMXREGS_BASE	 83
#define SSEREGS_BASE	 91
#define AVXREGS_BASE	107
#define CREGS_BASE		123
#define DREGS_BASE		139

#define INS_OP_EXT	0x0F
enum OP_CATEGORY : BYTE
{
	OC_NONE,
	OC_PREFIX,
	OC_INFO,
	OC_INFOEX,
	OC_EXT,
	OC_GROUP,
	OC_GRP_VEX,
	OC_GRP_C0,
	OC_FULL,
	OC_WITHPF,
	OC_VEX_C0,
};

typedef USHORT				OPBYTE_INFO;
#define MAX_OP_IDX			0x0FFF
#define MAKE_OPWORD(c, i)	((((c) & 0x0F) << 12) | ((i) & MAX_OP_IDX))
#define GET_OP_CAT(oi)		(OP_CATEGORY)(((oi) >> 12) & 0x0F)
#define GET_OP_IDX(oi)		(USHORT)((oi) & MAX_OP_IDX)

#define OTCAT_NONE			0
#define OTCAT_OP_REG		1
#define OTCAT_DIR_REG		2
#define OTCAT_READ_VAL		3
#define OTCAT_REG_MODRM		4
#define OTCAT_MORE_MODRM	5
#define OTCAT_MEM_REF		6
#define OTCAT_RM_FROM_RM	7
#define OTCAT_OPR_FUNC_CNT	8

enum OPRND_TYPE : BYTE
{
	OT_NONE,			// [ 0] 
	OT_FREG_SI,
	OT_OP_RB,
	OT_OP_R_ALL,
	OT_ACC8,
	OT_ACC16,
	OT_ACC_ALL_NO64,
	OT_ACC_ALL,
	OT_REG_CL,
	OT_REG_DX,
	OT_FREG_SI0,
	OT_REG_ESI,
	OT_REG_EDI,
	OT_SEG_PF,
	OT_REGI_EBXAL,
	OT_IMM8,
	OT_IMM_ALL,
	OT_IMM32,
	OT_IMM16,
	OT_SE_IMM8,
	OT_PTR16_ALL,
	OT_REL_8,
	OT_REL_16_32,
	OT_MOFFS8,
	OT_MOFFS_ALL,
	OT_CONST1,
	OT_REG8,
	OT_REG16,
	OT_REG_ALL,
	OT_REG32,
	OT_REG32_64,
	OT_REG32_64_RM,
	OT_REG_CR,
	OT_REG_DR,
	OT_REG_SEG,
	OT_MMX,
	OT_MMX_RM,
	OT_XMM,
	OT_XMM_RM,
	OT_VXMM,
	OT_YXMM,
	OT_YMM,
	OT_VYMM,
	OT_VYXMM,
	OT_WREG32_64,
	OT_XMM_IMM,
	OT_YXMM_IMM,
	OT_MEM64_128,
	OT_MEM32,
	OT_MEM32_64,
	OT_MEM64,
	OT_MEM128,
	OT_FPUM16,
	OT_FPUM32,
	OT_FPUM64,
	OT_FPUM80,
	OT_LMEM128_256,
	OT_VSIB_M32_64,
	OT_MEM,
	OT_MEM16_ALL,
	OT_M16_A_3264,
	OT_M1632_A_1632,
	OT_R_ALL_M16,
	OT_RM_ALL,
	OT_R32_64_M8,
	OT_R32_64_M16,
	OT_RM32_64,
	OT_RM16_32,
	OT_RM16,
	OT_RM8,
	OT_MMX32,
	OT_MMX64,
	OT_XMM16,
	OT_XMM32,
	OT_XMM64,
	OT_XMM128,
	OT_RM32,
	OT_R32_M8,
	OT_R32_M16,
	OT_YMM256,
	OT_YXMM64_256,
	OT_YXMM128_256,
	OT_WXMM32_64,
	OT_LXMM64_128,
	OT_WRM32_64,
	OT_REG32_64_M8,
	OT_REG32_64_M16,
	OT_MAX_TYPE
};

enum OP_IID : USHORT
{
	OI_UNKNOWN,			OI_ADD,				OI_PUSH,			OI_POP,
	OI_OR,				OI_ADC,				OI_SBB,				OI_AND,
	OI_DAA,				OI_SUB,				OI_DAS,				OI_XOR,
	OI_AAA,				OI_CMP,				OI_AAS,				OI_INC,
	OI_DEC,				OI_PUSHA,			OI_POPA,			OI_BOUND,
	OI_ARPL,			OI_IMUL,			OI_INS,				OI_OUTS,
	OI_JO,				OI_JNO,				OI_JB,				OI_JNB,
	OI_JZ,				OI_JNZ,				OI_JBE,				OI_JNBE,
	OI_JS,				OI_JNS,				OI_JP,				OI_JNP,
	OI_JL,				OI_JNL,				OI_JLE,				OI_JNLE,
	OI_TEST,			OI_XCHG,			OI_MOV,				OI_LEA,
	OI_CBW,				OI_CWDE,			OI_CDQE,			OI_CWD,
	OI_CDQ,				OI_CQO,				OI_CALL_FAR,		OI_PUSHF,
	OI_POPF,			OI_SAHF,			OI_LAHF,			OI_MOVS,
	OI_CMPS,			OI_STOS,			OI_LODS,			OI_SCAS,
	OI_RET,				OI_LES,				OI_LDS,				OI_ENTER,
	OI_LEAVE,			OI_RETF,			OI_INT_3,			OI_INT,
	OI_INTO,			OI_IRET,			OI_AAM,				OI_AAD,
	OI_SALC,			OI_XLAT,			OI_LOOPNZ,			OI_LOOPZ,
	OI_LOOP,			OI_JCXZ,			OI_JECXZ,			OI_JRCXZ,
	OI_IN,				OI_OUT,				OI_CALL,			OI_JMP,
	OI_JMP_FAR,			OI_INT1,			OI_HLT,				OI_CMC,
	OI_CLC,				OI_STC,				OI_CLI,				OI_STI,
	OI_CLD,				OI_STD,				OI_LAR,				OI_LSL,
	OI_SYSCALL,			OI_CLTS,			OI_SYSRET,			OI_INVD,
	OI_WBINVD,			OI_UD2,				OI_FEMMS,			OI_NOP,
	OI_WRMSR,			OI_RDTSC,			OI_RDMSR,			OI_RDPMC,
	OI_SYSENTER,		OI_SYSEXIT,			OI_GETSEC,			OI_CMOVO,
	OI_CMOVNO,			OI_CMOVB,			OI_CMOVAE,			OI_CMOVZ,
	OI_CMOVNZ,			OI_CMOVBE,			OI_CMOVA,			OI_CMOVS,
	OI_CMOVNS,			OI_CMOVP,			OI_CMOVNP,			OI_CMOVL,
	OI_CMOVGE,			OI_CMOVLE,			OI_CMOVG,			OI_SETO,
	OI_SETNO,			OI_SETB,			OI_SETAE,			OI_SETZ,
	OI_SETNZ,			OI_SETBE,			OI_SETA,			OI_SETS,
	OI_SETNS,			OI_SETP,			OI_SETNP,			OI_SETL,
	OI_SETGE,			OI_SETLE,			OI_SETG,			OI_CPUID,
	OI_BT,				OI_SHLD,			OI_RSM,				OI_BTS,
	OI_SHRD,			OI_CMPXCHG,			OI_LSS,				OI_BTR,
	OI_LFS,				OI_LGS,				OI_MOVZX,			OI_BTC,
	OI_MOVSX,			OI_XADD,			OI_MOVNTI,			OI_BSWAP,
	OI_ROL,				OI_ROR,				OI_RCL,				OI_RCR,
	OI_SHL,				OI_SHR,				OI_SAL,				OI_SAR,
	OI_FADD,			OI_FMUL,			OI_FCOM,			OI_FCOMP,
	OI_FSUB,			OI_FSUBR,			OI_FDIV,			OI_FDIVR,
	OI_FLD,				OI_FST,				OI_FSTP,			OI_FLDENV,
	OI_FLDCW,			OI_FXCH,			OI_FNOP,			OI_FCHS,
	OI_FABS,			OI_FTST,			OI_FXAM,			OI_FLD1,
	OI_FLDL2T,			OI_FLDL2E,			OI_FLDPI,			OI_FLDLG2,
	OI_FLDLN2,			OI_FLDZ,			OI_F2XM1,			OI_FYL2X,
	OI_FPTAN,			OI_FPATAN,			OI_FXTRACT,			OI_FPREM1,
	OI_FDECSTP,			OI_FINCSTP,			OI_FPREM,			OI_FYL2XP1,
	OI_FSQRT,			OI_FSINCOS,			OI_FRNDINT,			OI_FSCALE,
	OI_FSIN,			OI_FCOS,			OI_FIADD,			OI_FIMUL,
	OI_FICOM,			OI_FICOMP,			OI_FISUB,			OI_FISUBR,
	OI_FIDIV,			OI_FIDIVR,			OI_FCMOVB,			OI_FCMOVE,
	OI_FCMOVBE,			OI_FCMOVU,			OI_FUCOMPP,			OI_FILD,
	OI_FISTTP,			OI_FIST,			OI_FISTP,			OI_FCMOVNB,
	OI_FCMOVNE,			OI_FCMOVNBE,		OI_FCMOVNU,			OI_FENI,
	OI_FEDISI,			OI_FSETPM,			OI_FUCOMI,			OI_FCOMI,
	OI_FRSTOR,			OI_FFREE,			OI_FUCOM,			OI_FUCOMP,
	OI_FADDP,			OI_FMULP,			OI_FCOMPP,			OI_FSUBRP,
	OI_FSUBP,			OI_FDIVRP,			OI_FDIVP,			OI_FBLD,
	OI_FBSTP,			OI_FUCOMIP,			OI_FCOMIP,			OI_NOT,
	OI_NEG,				OI_MUL,				OI_DIV,				OI_IDIV,
	OI_SLDT,			OI_STR,				OI_LLDT,			OI_LTR,
	OI_VERR,			OI_VERW,			OI_SGDT,			OI_SIDT,
	OI_LGDT,			OI_LIDT,			OI_SMSW,			OI_LMSW,
	OI_INVLPG,			OI_VMCALL,			OI_VMLAUNCH,		OI_VMRESUME,
	OI_VMXOFF,			OI_MONITOR,			OI_MWAIT,			OI_XGETBV,
	OI_XSETBV,			OI_VMFUNC,			OI_VMRUN,			OI_VMMCALL,
	OI_VMLOAD,			OI_VMSAVE,			OI_STGI,			OI_CLGI,
	OI_SKINIT,			OI_INVLPGA,			OI_SWAPGS,			OI_RDTSCP,
	OI_PREFETCH,		OI_PREFETCHW,		OI_PI2FW,			OI_PI2FD,
	OI_PF2IW,			OI_PF2ID,			OI_PFNACC,			OI_PFPNACC,
	OI_PFCMPGE,			OI_PFMIN,			OI_PFRCP,			OI_PFRSQRT,
	OI_PFSUB,			OI_PFADD,			OI_PFCMPGT,			OI_PFMAX,
	OI_PFRCPIT1,		OI_PFRSQIT1,		OI_PFSUBR,			OI_PFACC,
	OI_PFCMPEQ,			OI_PFMUL,			OI_PFRCPIT2,		OI_PMULHRW,
	OI_PSWAPD,			OI_PAVGUSB,			OI_MOVUPS,			OI_MOVUPD,
	OI_MOVSS,			OI_MOVSD,			OI_VMOVUPS,			OI_VMOVUPD,
	OI_VMOVSS,			OI_VMOVSD,			OI_MOVHLPS,			OI_MOVLPS,
	OI_MOVLPD,			OI_MOVSLDUP,		OI_MOVDDUP,			OI_VMOVHLPS,
	OI_VMOVLPS,			OI_VMOVLPD,			OI_VMOVSLDUP,		OI_VMOVDDUP,
	OI_UNPCKLPS,		OI_UNPCKLPD,		OI_VUNPCKLPS,		OI_VUNPCKLPD,
	OI_UNPCKHPS,		OI_UNPCKHPD,		OI_VUNPCKHPS,		OI_VUNPCKHPD,
	OI_MOVLHPS,			OI_MOVHPS,			OI_MOVHPD,			OI_MOVSHDUP,
	OI_VMOVLHPS,		OI_VMOVHPS,			OI_VMOVHPD,			OI_VMOVSHDUP,
	OI_PREFETCHNTA,		OI_PREFETCHT0,		OI_PREFETCHT1,		OI_PREFETCHT2,
	OI_MOVAPS,			OI_MOVAPD,			OI_VMOVAPS,			OI_VMOVAPD,
	OI_CVTPI2PS,		OI_CVTPI2PD,		OI_CVTSI2SS,		OI_CVTSI2SD,
	OI_VCVTSI2SS,		OI_VCVTSI2SD,		OI_MOVNTPS,			OI_MOVNTPD,
	OI_MOVNTSS,			OI_MOVNTSD,			OI_VMOVNTPS,		OI_VMOVNTPD,
	OI_CVTTPS2PI,		OI_CVTTPD2PI,		OI_CVTTSS2SI,		OI_CVTTSD2SI,
	OI_VCVTTSS2SI,		OI_VCVTTSD2SI,		OI_CVTPS2PI,		OI_CVTPD2PI,
	OI_CVTSS2SI,		OI_CVTSD2SI,		OI_VCVTSS2SI,		OI_VCVTSD2SI,
	OI_UCOMISS,			OI_UCOMISD,			OI_VUCOMISS,		OI_VUCOMISD,
	OI_COMISS,			OI_COMISD,			OI_VCOMISS,			OI_VCOMISD,
	OI_MOVMSKPS,		OI_MOVMSKPD,		OI_VMOVMSKPS,		OI_VMOVMSKPD,
	OI_SQRTPS,			OI_SQRTPD,			OI_SQRTSS,			OI_SQRTSD,
	OI_VSQRTPS,			OI_VSQRTPD,			OI_VSQRTSS,			OI_VSQRTSD,
	OI_RSQRTPS,			OI_RSQRTSS,			OI_VRSQRTPS,		OI_VRSQRTSS,
	OI_RCPPS,			OI_RCPSS,			OI_VRCPPS,			OI_VRCPSS,
	OI_ANDPS,			OI_ANDPD,			OI_VANDPS,			OI_VANDPD,
	OI_ANDNPS,			OI_ANDNPD,			OI_VANDNPS,			OI_VANDNPD,
	OI_ORPS,			OI_ORPD,			OI_VORPS,			OI_VORPD,
	OI_XORPS,			OI_XORPD,			OI_VXORPS,			OI_VXORPD,
	OI_ADDPS,			OI_ADDPD,			OI_ADDSS,			OI_ADDSD,
	OI_VADDPS,			OI_VADDPD,			OI_VADDSS,			OI_VADDSD,
	OI_MULPS,			OI_MULPD,			OI_MULSS,			OI_MULSD,
	OI_VMULPS,			OI_VMULPD,			OI_VMULSS,			OI_VMULSD,
	OI_CVTPS2PD,		OI_CVTPD2PS,		OI_CVTSS2SD,		OI_CVTSD2SS,
	OI_VCVTPS2PD,		OI_VCVTPD2PS,		OI_VCVTSS2SD,		OI_VCVTSD2SS,
	OI_CVTDQ2PS,		OI_CVTPS2DQ,		OI_CVTTPS2DQ,		OI_VCVTDQ2PS,
	OI_VCVTPS2DQ,		OI_VCVTTPS2DQ,		OI_SUBPS,			OI_SUBPD,
	OI_SUBSS,			OI_SUBSD,			OI_VSUBPS,			OI_VSUBPD,
	OI_VSUBSS,			OI_VSUBSD,			OI_MINPS,			OI_MINPD,
	OI_MINSS,			OI_MINSD,			OI_VMINPS,			OI_VMINPD,
	OI_VMINSS,			OI_VMINSD,			OI_DIVPS,			OI_DIVPD,
	OI_DIVSS,			OI_DIVSD,			OI_VDIVPS,			OI_VDIVPD,
	OI_VDIVSS,			OI_VDIVSD,			OI_MAXPS,			OI_MAXPD,
	OI_MAXSS,			OI_MAXSD,			OI_VMAXPS,			OI_VMAXPD,
	OI_VMAXSS,			OI_VMAXSD,			OI_PUNPCKLBW,		OI_VPUNPCKLBW,
	OI_PUNPCKLWD,		OI_VPUNPCKLWD,		OI_PUNPCKLDQ,		OI_VPUNPCKLDQ,
	OI_PACKSSWB,		OI_VPACKSSWB,		OI_PCMPGTB,			OI_VPCMPGTB,
	OI_PCMPGTW,			OI_VPCMPGTW,		OI_PCMPGTD,			OI_VPCMPGTD,
	OI_PACKUSWB,		OI_VPACKUSWB,		OI_PUNPCKHBW,		OI_VPUNPCKHBW,
	OI_PUNPCKHWD,		OI_VPUNPCKHWD,		OI_PUNPCKHDQ,		OI_VPUNPCKHDQ,
	OI_PACKSSDW,		OI_VPACKSSDW,		OI_PUNPCKLQDQ,		OI_VPUNPCKLQDQ,
	OI_PUNPCKHQDQ,		OI_VPUNPCKHQDQ,		OI_MOVD,			OI_MOVQ,
	OI_VMOVD,			OI_VMOVQ,			OI_MOVDQA,			OI_MOVDQU,
	OI_VMOVDQA,			OI_VMOVDQU,			OI_PSHUFW,			OI_PSHUFD,
	OI_PSHUFHW,			OI_PSHUFLW,			OI_VPSHUFD,			OI_VPSHUFHW,
	OI_VPSHUFLW,		OI_PCMPEQB,			OI_VPCMPEQB,		OI_PCMPEQW,
	OI_VPCMPEQW,		OI_PCMPEQD,			OI_VPCMPEQD,		OI_EMMS,
	OI_VZEROUPPER,		OI_VZEROALL,		OI_VMREAD,			OI_EXTRQ,
	OI_INSERTQ,			OI_VMWRITE,			OI_CVTPH2PS,		OI_CVTPS2PH,
	OI_HADDPD,			OI_HADDPS,			OI_VHADDPD,			OI_VHADDPS,
	OI_HSUBPD,			OI_HSUBPS,			OI_VHSUBPD,			OI_VHSUBPS,
	OI_XSAVE,			OI_XSAVE64,			OI_LFENCE,			OI_XRSTOR,
	OI_XRSTOR64,		OI_MFENCE,			OI_XSAVEOPT,		OI_XSAVEOPT64,
	OI_SFENCE,			OI_CLFLUSH,			OI_POPCNT,			OI_BSF,
	OI_TZCNT,			OI_BSR,				OI_LZCNT,			OI_CMPEQPS,
	OI_CMPLTPS,			OI_CMPLEPS,			OI_CMPUNORDPS,		OI_CMPNEQPS,
	OI_CMPNLTPS,		OI_CMPNLEPS,		OI_CMPORDPS,		OI_CMPEQPD,
	OI_CMPLTPD,			OI_CMPLEPD,			OI_CMPUNORDPD,		OI_CMPNEQPD,
	OI_CMPNLTPD,		OI_CMPNLEPD,		OI_CMPORDPD,		OI_CMPEQSS,
	OI_CMPLTSS,			OI_CMPLESS,			OI_CMPUNORDSS,		OI_CMPNEQSS,
	OI_CMPNLTSS,		OI_CMPNLESS,		OI_CMPORDSS,		OI_CMPEQSD,
	OI_CMPLTSD,			OI_CMPLESD,			OI_CMPUNORDSD,		OI_CMPNEQSD,
	OI_CMPNLTSD,		OI_CMPNLESD,		OI_CMPORDSD,		OI_VCMPEQPS,
	OI_VCMPLTPS,		OI_VCMPLEPS,		OI_VCMPUNORDPS,		OI_VCMPNEQPS,
	OI_VCMPNLTPS,		OI_VCMPNLEPS,		OI_VCMPORDPS,		OI_VCMPEQ_UQPS,
	OI_VCMPNGEPS,		OI_VCMPNGTPS,		OI_VCMPFALSEPS,		OI_VCMPNEQ_OQPS,
	OI_VCMPGEPS,		OI_VCMPGTPS,		OI_VCMPTRUEPS,		OI_VCMPEQ_OSPS,
	OI_VCMPLT_OQPS,		OI_VCMPLE_OQPS,		OI_VCMPUNORD_SPS,	OI_VCMPNEQ_USPS,
	OI_VCMPNLT_UQPS,	OI_VCMPNLE_UQPS,	OI_VCMPORD_SPS,		OI_VCMPEQ_USPS,
	OI_VCMPNGE_UQPS,	OI_VCMPNGT_UQPS,	OI_VCMPFALSE_OSPS,	OI_VCMPNEQ_OSPS,
	OI_VCMPGE_OQPS,		OI_VCMPGT_OQPS,		OI_VCMPTRUE_USPS,	OI_VCMPEQPD,
	OI_VCMPLTPD,		OI_VCMPLEPD,		OI_VCMPUNORDPD,		OI_VCMPNEQPD,
	OI_VCMPNLTPD,		OI_VCMPNLEPD,		OI_VCMPORDPD,		OI_VCMPEQ_UQPD,
	OI_VCMPNGEPD,		OI_VCMPNGTPD,		OI_VCMPFALSEPD,		OI_VCMPNEQ_OQPD,
	OI_VCMPGEPD,		OI_VCMPGTPD,		OI_VCMPTRUEPD,		OI_VCMPEQ_OSPD,
	OI_VCMPLT_OQPD,		OI_VCMPLE_OQPD,		OI_VCMPUNORD_SPD,	OI_VCMPNEQ_USPD,
	OI_VCMPNLT_UQPD,	OI_VCMPNLE_UQPD,	OI_VCMPORD_SPD,		OI_VCMPEQ_USPD,
	OI_VCMPNGE_UQPD,	OI_VCMPNGT_UQPD,	OI_VCMPFALSE_OSPD,	OI_VCMPNEQ_OSPD,
	OI_VCMPGE_OQPD,		OI_VCMPGT_OQPD,		OI_VCMPTRUE_USPD,	OI_VCMPEQSS,
	OI_VCMPLTSS,		OI_VCMPLESS,		OI_VCMPUNORDSS,		OI_VCMPNEQSS,
	OI_VCMPNLTSS,		OI_VCMPNLESS,		OI_VCMPORDSS,		OI_VCMPEQ_UQSS,
	OI_VCMPNGESS,		OI_VCMPNGTSS,		OI_VCMPFALSESS,		OI_VCMPNEQ_OQSS,
	OI_VCMPGESS,		OI_VCMPGTSS,		OI_VCMPTRUESS,		OI_VCMPEQ_OSSS,
	OI_VCMPLT_OQSS,		OI_VCMPLE_OQSS,		OI_VCMPUNORD_SSS,	OI_VCMPNEQ_USSS,
	OI_VCMPNLT_UQSS,	OI_VCMPNLE_UQSS,	OI_VCMPORD_SSS,		OI_VCMPEQ_USSS,
	OI_VCMPNGE_UQSS,	OI_VCMPNGT_UQSS,	OI_VCMPFALSE_OSSS,	OI_VCMPNEQ_OSSS,
	OI_VCMPGE_OQSS,		OI_VCMPGT_OQSS,		OI_VCMPTRUE_USSS,	OI_VCMPEQSD,
	OI_VCMPLTSD,		OI_VCMPLESD,		OI_VCMPUNORDSD,		OI_VCMPNEQSD,
	OI_VCMPNLTSD,		OI_VCMPNLESD,		OI_VCMPORDSD,		OI_VCMPEQ_UQSD,
	OI_VCMPNGESD,		OI_VCMPNGTSD,		OI_VCMPFALSESD,		OI_VCMPNEQ_OQSD,
	OI_VCMPGESD,		OI_VCMPGTSD,		OI_VCMPTRUESD,		OI_VCMPEQ_OSSD,
	OI_VCMPLT_OQSD,		OI_VCMPLE_OQSD,		OI_VCMPUNORD_SSD,	OI_VCMPNEQ_USSD,
	OI_VCMPNLT_UQSD,	OI_VCMPNLE_UQSD,	OI_VCMPORD_SSD,		OI_VCMPEQ_USSD,
	OI_VCMPNGE_UQSD,	OI_VCMPNGT_UQSD,	OI_VCMPFALSE_OSSD,	OI_VCMPNEQ_OSSD,
	OI_VCMPGE_OQSD,		OI_VCMPGT_OQSD,		OI_VCMPTRUE_USSD,	OI_PINSRW,
	OI_VPINSRW,			OI_PEXTRW,			OI_VPEXTRW,			OI_SHUFPS,
	OI_SHUFPD,			OI_VSHUFPS,			OI_VSHUFPD,			OI_CMPXCHG8B,
	OI_CMPXCHG16B,		OI_VMPTRST,			OI_ADDSUBPD,		OI_ADDSUBPS,
	OI_VADDSUBPD,		OI_VADDSUBPS,		OI_PSRLW,			OI_VPSRLW,
	OI_PSRLD,			OI_VPSRLD,			OI_PSRLQ,			OI_VPSRLQ,
	OI_PADDQ,			OI_VPADDQ,			OI_PMULLW,			OI_VPMULLW,
	OI_MOVQ2DQ,			OI_MOVDQ2Q,			OI_PMOVMSKB,		OI_VPMOVMSKB,
	OI_PSUBUSB,			OI_VPSUBUSB,		OI_PSUBUSW,			OI_VPSUBUSW,
	OI_PMINUB,			OI_VPMINUB,			OI_PAND,			OI_VPAND,
	OI_PADDUSB,			OI_VPADDUSW,		OI_PADDUSW,			OI_PMAXUB,
	OI_VPMAXUB,			OI_PANDN,			OI_VPANDN,			OI_PAVGB,
	OI_VPAVGB,			OI_PSRAW,			OI_VPSRAW,			OI_PSRAD,
	OI_VPSRAD,			OI_PAVGW,			OI_VPAVGW,			OI_PMULHUW,
	OI_VPMULHUW,		OI_PMULHW,			OI_VPMULHW,			OI_CVTTPD2DQ,
	OI_CVTDQ2PD,		OI_CVTPD2DQ,		OI_VCVTTPD2DQ,		OI_VCVTDQ2PD,
	OI_VCVTPD2DQ,		OI_MOVNTQ,			OI_MOVNTDQ,			OI_VMOVNTDQ,
	OI_PSUBSB,			OI_VPSUBSB,			OI_PSUBSW,			OI_VPSUBSW,
	OI_PMINSW,			OI_VPMINSW,			OI_POR,				OI_VPOR,
	OI_PADDSB,			OI_VPADDSB,			OI_PADDSW,			OI_VPADDSW,
	OI_PMAXSW,			OI_VPMAXSW,			OI_PXOR,			OI_VPXOR,
	OI_LDDQU,			OI_VLDDQU,			OI_PSLLW,			OI_VPSLLW,
	OI_PSLLD,			OI_VPSLLD,			OI_PSLLQ,			OI_VPSLLQ,
	OI_PMULUDQ,			OI_VPMULUDQ,		OI_PMADDWD,			OI_VPMADDWD,
	OI_PSADBW,			OI_VPSADBW,			OI_MASKMOVQ,		OI_MASKMOVDQU,
	OI_VMASKMOVDQU,		OI_PSUBB,			OI_VPSUBB,			OI_PSUBW,
	OI_VPSUBW,			OI_PSUBD,			OI_VPSUBD,			OI_PSUBQ,
	OI_VPSUBQ,			OI_PADDB,			OI_VPADDB,			OI_PADDW,
	OI_VPADDW,			OI_PADDD,			OI_VPADDD,			OI_FNSTENV,
	OI_FSTENV,			OI_FNSTCW,			OI_FSTCW,			OI_FNCLEX,
	OI_FCLEX,			OI_FNINIT,			OI_FINIT,			OI_FNSAVE,
	OI_FSAVE,			OI_FNSTSW,			OI_FSTSW,			OI_PSHUFB,
	OI_VPSHUFB,			OI_PHADDW,			OI_VPHADDW,			OI_PHADDD,
	OI_VPHADDD,			OI_PHADDSW,			OI_VPHADDSW,		OI_PMADDUBSW,
	OI_VPMADDUBSW,		OI_PHSUBW,			OI_VPHSUBW,			OI_PHSUBD,
	OI_VPHSUBD,			OI_PHSUBSW,			OI_VPHSUBSW,		OI_PSIGNB,
	OI_VPSIGNB,			OI_PSIGNW,			OI_VPSIGNW,			OI_PSIGND,
	OI_VPSIGND,			OI_PMULHRSW,		OI_VPMULHRSW,		OI_VPERMILPS,
	OI_VPERMILPD,		OI_VTESTPS,			OI_VTESTPD,			OI_PBLENDVB,
	OI_BLENDVPS,		OI_BLENDVPD,		OI_PTEST,			OI_VPTEST,
	OI_VBROADCASTSS,	OI_VBROADCASTSD,	OI_VBROADCASTF128,	OI_PABSB,
	OI_VPABSB,			OI_PABSW,			OI_VPABSW,			OI_PABSD,
	OI_VPABSD,			OI_PMOVSXBW,		OI_VPMOVSXBW,		OI_PMOVSXBD,
	OI_VPMOVSXBD,		OI_PMOVSXBQ,		OI_VPMOVSXBQ,		OI_PMOVSXWD,
	OI_VPMOVSXWD,		OI_PMOVSXWQ,		OI_VPMOVSXWQ,		OI_PMOVSXDQ,
	OI_VPMOVSXDQ,		OI_PMULDQ,			OI_VPMULDQ,			OI_PCMPEQQ,
	OI_VPCMPEQQ,		OI_MOVNTDQA,		OI_VMOVNTDQA,		OI_PACKUSDW,
	OI_VPACKUSDW,		OI_VMASKMOVPS,		OI_VMASKMOVPD,		OI_PMOVZXBW,
	OI_VPMOVZXBW,		OI_PMOVZXBD,		OI_VPMOVZXBD,		OI_PMOVZXBQ,
	OI_VPMOVZXBQ,		OI_PMOVZXWD,		OI_VPMOVZXWD,		OI_PMOVZXWQ,
	OI_VPMOVZXWQ,		OI_PMOVZXDQ,		OI_VPMOVZXDQ,		OI_PCMPGTQ,
	OI_VPCMPGTQ,		OI_PMINSB,			OI_VPMINSB,			OI_PMINSD,
	OI_VPMINSD,			OI_PMINUW,			OI_VPMINUW,			OI_PMINUD,
	OI_VPMINUD,			OI_PMAXSB,			OI_VPMAXSB,			OI_PMAXSD,
	OI_VPMAXSD,			OI_PMAXUW,			OI_VPMAXUW,			OI_PMAXUD,
	OI_VPMAXUD,			OI_PMULLD,			OI_VPMULLD,			OI_PHMINPOSUW,
	OI_VPHMINPOSUW,		OI_INVEPT,			OI_INVVPID,			OI_INVPCID,
	OI_VFMADDSUB132PS,	OI_VFMADDSUB132PD,	OI_VFMSUBADD132PS,	OI_VFMSUBADD132PD,
	OI_VFMADD132PS,		OI_VFMADD132PD,		OI_VFMADD132SS,		OI_VFMADD132SD,
	OI_VFMSUB132PS,		OI_VFMSUB132PD,		OI_VFMSUB132SS,		OI_VFMSUB132SD,
	OI_VFNMADD132PS,	OI_VFNMADD132PD,	OI_VFNMADD132SS,	OI_VFNMADD132SD,
	OI_VFNMSUB132PS,	OI_VFNMSUB132PD,	OI_VFNMSUB132SS,	OI_VFNMSUB132SD,
	OI_VFMADDSUB213PS,	OI_VFMADDSUB213PD,	OI_VFMSUBADD213PS,	OI_VFMSUBADD213PD,
	OI_VFMADD213PS,		OI_VFMADD213PD,		OI_VFMADD213SS,		OI_VFMADD213SD,
	OI_VFMSUB213PS,		OI_VFMSUB213PD,		OI_VFMSUB213SS,		OI_VFMSUB213SD,
	OI_VFNMADD213PS,	OI_VFNMADD213PD,	OI_VFNMADD213SS,	OI_VFNMADD213SD,
	OI_VFNMSUB213PS,	OI_VFNMSUB213PD,	OI_VFNMSUB213SS,	OI_VFNMSUB213SD,
	OI_VFMADDSUB231PS,	OI_VFMADDSUB231PD,	OI_VFMSUBADD231PS,	OI_VFMSUBADD231PD,
	OI_VFMADD231PS,		OI_VFMADD231PD,		OI_VFMADD231SS,		OI_VFMADD231SD,
	OI_VFMSUB231PS,		OI_VFMSUB231PD,		OI_VFMSUB231SS,		OI_VFMSUB231SD,
	OI_VFNMADD231PS,	OI_VFNMADD231PD,	OI_VFNMADD231SS,	OI_VFNMADD231SD,
	OI_VFNMSUB231PS,	OI_VFNMSUB231PD,	OI_VFNMSUB231SS,	OI_VFNMSUB231SD,
	OI_AESIMC,			OI_VAESIMC,			OI_AESENC,			OI_VAESENC,
	OI_AESENCLAST,		OI_VAESENCLAST,		OI_AESDEC,			OI_VAESDEC,
	OI_AESDECLAST,		OI_VAESDECLAST,		OI_MOVBE,			OI_CRC32,
	OI_VPERM2F128,		OI_ROUNDPS,			OI_VROUNDPS,		OI_ROUNDPD,
	OI_VROUNDPD,		OI_ROUNDSS,			OI_VROUNDSS,		OI_ROUNDSD,
	OI_VROUNDSD,		OI_BLENDPS,			OI_VBLENDPS,		OI_BLENDPD,
	OI_VBLENDPD,		OI_PBLENDW,			OI_VPBLENDW,		OI_PALIGNR,
	OI_VPALIGNR,		OI_PEXTRB,			OI_VPEXTRB,			OI_PEXTRD,
	OI_PEXTRQ,			OI_VPEXTRD,			OI_VPEXTRQ,			OI_EXTRACTPS,
	OI_VEXTRACTPS,		OI_VINSERTF128,		OI_VEXTRACTF128,	OI_PINSRB,
	OI_VPINSRB,			OI_INSERTPS,		OI_VINSERTPS,		OI_PINSRD,
	OI_PINSRQ,			OI_VPINSRD,			OI_VPINSRQ,			OI_DPPS,
	OI_VDPPS,			OI_DPPD,			OI_VDPPD,			OI_MPSADBW,
	OI_VMPSADBW,		OI_PCLMULQDQ,		OI_VPCLMULQDQ,		OI_VBLENDVPS,
	OI_VBLENDVPD,		OI_VPBLENDVB,		OI_PCMPESTRM,		OI_VPCMPESTRM,
	OI_PCMPESTRI,		OI_VPCMPESTRI,		OI_PCMPISTRM,		OI_VPCMPISTRM,
	OI_PCMPISTRI,		OI_VPCMPISTRI,		OI_AESKEYGENASSIST,	OI_VAESKEYGENASSIST,
	OI_PSRLDQ,			OI_VPSRLDQ,			OI_PSLLDQ,			OI_VPSLLDQ,
	OI_FXSAVE,			OI_FXSAVE64,		OI_RDFSBASE,		OI_FXRSTOR,
	OI_FXRSTOR64,		OI_RDGSBASE,		OI_LDMXCSR,			OI_WRFSBASE,
	OI_VLDMXCSR,		OI_STMXCSR,			OI_WRGSBASE,		OI_VSTMXCSR,
	OI_VMPTRLD,			OI_VMCLEAR,			OI_VMXON,			OI_MOVSXD,
	OI_PAUSE,			OI_WAIT,			OI_RDRAND,			OI_RDSEED,
	//-------------------------------------------------------------------------------//
	OI_VPERMQ, OI_VPERMPD, OI_VPBLENDD, OI_VPERM2I128,
	OI_VCVTPS2PH,		OI_VCVTPH2PS,		OI_VINSERTI128,		OI_VEXTRACTI128, 
	OI_RORX,			OI_VPERMPS,			OI_VPERMD,			OI_VPSRLVD,
	OI_VPSRAVD,			OI_VPSLLVD,			OI_VPSLLVQ,			OI_VPBROADCASTD,
	OI_VPBROADCASTQ,	OI_VPSRLVQ,			OI_VBROADCASTI128, OI_VPBROADCASTB, 
	OI_VPBROADCASTW,	OI_VPGATHERDD,		OI_VPGATHERDQ,		OI_VPGATHERQD,		
	OI_VPGATHERQQ,		OI_VGATHERDPS,		OI_VGATHERDPD,		OI_VGATHERQPS,		
	OI_VGATHERQPD,		OI_VPMASKMOVD,		OI_VPMASKMOVQ,		OI_ANDN,
	OI_BZHI,			OI_BEXTR,			OI_PEXT,			OI_PDEP,
	OI_ADCX,			OI_ADOX,			OI_MULX,			OI_SHLX,
	OI_SARX,			OI_SHRX,			OI_BLSR,			OI_BLSMSK,
	OI_BLSI
};

enum REG_IID : BYTE
{
	R_RAX  , R_RCX	, R_RDX	 , R_RBX  , R_RSP  , R_RBP  , R_RSI  , R_RDI  , 
	R_R8   , R_R9	, R_R10	 , R_R11  , R_R12  , R_R13  , R_R14  , R_R15  ,
	R_EAX  , R_ECX	, R_EDX	 , R_EBX  , R_ESP  , R_EBP  , R_ESI  , R_EDI  , 
	R_R8D  , R_R9D	, R_R10D , R_R11D , R_R12D , R_R13D , R_R14D , R_R15D ,
	R_AX   , R_CX	, R_DX	 , R_BX	  , R_SP   , R_BP   , R_SI   , R_DI   , 
	R_R8W  , R_R9W  , R_R10W , R_R11W , R_R12W , R_R13W , R_R14W , R_R15W ,
	R_AL   , R_CL	, R_DL	 , R_BL   , R_AH   , R_CH   , R_DH   , R_BH   , 
	R_R8B  , R_R9B  , R_R10B , R_R11B , R_R12B , R_R13B , R_R14B , R_R15B ,
	R_SPL  , R_BPL	, R_SIL	 , R_DIL  ,
	R_ES   , R_CS	, R_SS	 , R_DS   , R_FS   , R_GS   ,
	R_RIP  ,
	R_ST0  , R_ST1	, R_ST2	 , R_ST3  , R_ST4  , R_ST5  , R_ST6  , R_ST7  ,
	R_MM0  , R_MM1	, R_MM2	 , R_MM3  , R_MM4  , R_MM5  , R_MM6  , R_MM7  ,
	R_XMM0 , R_XMM1 , R_XMM2 , R_XMM3 , R_XMM4 , R_XMM5 , R_XMM6 , R_XMM7 , 
	R_XMM8 , R_XMM9 , R_XMM10, R_XMM11, R_XMM12, R_XMM13, R_XMM14, R_XMM15,
	R_YMM0 , R_YMM1 , R_YMM2 , R_YMM3 , R_YMM4 , R_YMM5 , R_YMM6 , R_YMM7 , 
	R_YMM8 , R_YMM9 , R_YMM10, R_YMM11, R_YMM12, R_YMM13, R_YMM14, R_YMM15,
	R_CR0  , R_CR1	, R_CR2	 , R_CR3  , R_CR4  , R_CR5  , R_CR6  , R_CR7  , 
	R_CR8  , R_CR9	, R_CR10 , R_CR11 , R_CR13 , R_CR14 , R_CR15 ,
	R_DR0  , R_DR1	, R_DR2	 , R_DR3  , R_DR4  , R_DR5  , R_DR6  , R_DR7  ,
	R_DR8  , R_DR9	, R_DR10 , R_DR11 , R_DR13 , R_DR14 , R_DR15
};

enum OP_SIZE : UINT8
{
	OPR_SZ0, 
	OPR_SZ8, OPR_SZ16 , OPR_SZ32 , OPR_SZ64, 
	OPR_SZ128, OPR_SZ256, 
	OPR_SZ48, OPR_SZ80
};

typedef UINT OP_ATTRS;
/* Empty flags indicator: */
#define OPAF_FLAGS_NONE		(0)
/*
* Prefix flags (6 types: lock/rep, seg override, addr-size, oper-size, REX, VEX)
* There are several specific instructions that can follow LOCK prefix,
* note that they must be using a memory operand form, otherwise they generate an exception.
*/
#define OPAF_PRE_LOCK				0x00000001 // (1 << 0)
/* REPNZ prefix for string instructions only - means an instruction can follow it. */
#define OPAF_PRE_REPNZ				0x00000002 // (1 << 1)
/* REP prefix for string instructions only - means an instruction can follow it. */
#define OPAF_PRE_REP				0x00000004 // (1 << 2)
/* CS override prefix. */
#define OPAF_PRE_CS					0x00000008 // (1 << 3)
/* SS override prefix. */
#define OPAF_PRE_SS					0x00000010 // (1 << 4)
/* DS override prefix. */
#define OPAF_PRE_DS					0x00000020 // (1 << 5)
/* ES override prefix. */
#define OPAF_PRE_ES					0x00000040 // (1 << 6)
/* FS override prefix. Funky Segment :) */
#define OPAF_PRE_FS					0x00000080 // (1 << 7)
/* GS override prefix. Groovy Segment, of course not, duh ! */
#define OPAF_PRE_GS					0x00000100 // (1 << 8)
/* Switch operand size from 32 to 16 and vice versa. */
#define OPAF_PRE_OP_SIZE			0x00000200 // (1 << 9)
/* Switch address size from 32 to 16 and vice versa. */
#define OPAF_PRE_AD_SIZE			0x00000400 // (1 << 10)
/* Indicates the instruction must be REX prefixed in order to use 64 bits operands. */
#define OPAF_PRE_REX				0x00000800 // (1 << 11)
/* Indicates that instruction is encoded with a VEX prefix. */
#define OPAF_PRE_VEX				0x00001000 // (1 << 12)


/* The instruction we are going to decode requires ModR/M encoding. */
#define OPAF_MODRM_REQUIRED			0x00002000 // (1 << 13)
/* Special treatment for instructions which are in the divided-category but still needs the whole byte for ModR/M... */
#define OPAF_NOT_DIVIDED			0x00004000 // (1 << 14)
/*
* Used explicitly in repeatable instructions,
* which needs a suffix letter in their mnemonic to specify operation-size (depend on operands).
*/
#define OPAF_16BITS					0x00008000 // (1 << 15)
/* If the _opCode is supported by 80286 and upper models (16/32 bits). */
#define OPAF_32BITS					0x00010000 // (1 << 16)

/* Native instructions which needs suffix letter to indicate their operation-size (and don't depend on operands). */
#define OPAF_NATIVE					0x00020000 // (1 << 17)
/* Use extended mnemonic, means it's an _InstInfoEx structure, which contains another mnemonic for 32 bits specifically. */
#define OPAF_USE_EXMNEMONIC			0x00040000 // (1 << 18)
/* Use third operand, means it's an _InstInfoEx structure, which contains another operand for special instructions. */
#define OPAF_USE_OP3				0x00080000 // (1 << 19)
/* Use fourth operand, means it's an _InstInfoEx structure, which contains another operand for special instructions. */
#define OPAF_USE_OP4				0x00100000 // (1 << 20)
/* The instruction's mnemonic depends on the mod value of the ModR/M byte (mod=11, mod!=11). */
#define OPAF_MNEMONIC_MODRM_BASED	0x00200000 // (1 << 21)
/* The instruction uses a ModR/M byte which the MOD must be 11 (for registers operands only). */
#define OPAF_MODRR_REQUIRED			0x00400000 // (1 << 22)
/* The way of 3DNow! instructions are built, we have to handle their locating specially. Suffix imm8 tells which instruction it is. */
#define OPAF_3DNOW_FETCH			0x00800000 // (1 << 23)
/* The instruction needs two suffixes, one for the comparison type (imm8) and the second for its operation size indication (second mnemonic). */
#define OPAF_PSEUDO_OPCODE			0x01000000 // (1 << 24)
/* Invalid instruction at 64 bits decoding mode. */
#define OPAF_INVALID_64BITS			0x02000000 // (1 << 25)
/* Specific instruction can be promoted to 64 bits (without REX, it is promoted automatically). */
#define OPAF_64BITS					0x04000000 // (1 << 26)
/* Third mnemonic is set. */
#define OPAF_USE_EXMNEMONIC2		0x08000000 // (1 << 27)
/* Instruction is only valid in 64 bits decoding mode. */
#define OPAF_64BITS_FETCH			0x10000000 // (1 << 28)
/* Forces that the ModRM-REG/Opcode field will be 0. (For EXTRQ). */
#define OPAF_FORCE_REG0				0x20000000 // (1 << 29)
/* Indicates that the instruction is encoded with a ModRM byte (REG field specifically). */
#define OPAF_MODRM_INCLUDED			0x40000000 // (1 << 30)
/* Indicates that the first (/destination) operand of the instruction is writable. */
#define OPAF_DST_WR					0x80000000 // (1 << 31)

#define OPAF_PRE_REPS			(OPAF_PRE_REPNZ | OPAF_PRE_REP)
#define OPAF_PRE_LOKREP_MASK	(OPAF_PRE_LOCK | OPAF_PRE_REPNZ | OPAF_PRE_REP)
#define OPAF_PRE_SEGOVRD_MASK32	(OPAF_PRE_CS | OPAF_PRE_SS | OPAF_PRE_DS | OPAF_PRE_ES)
#define OPAF_PRE_SEGOVRD_MASK64	(OPAF_PRE_FS | OPAF_PRE_GS)
#define OPAF_PRE_SEGOVRD_MASK	(OPAF_PRE_SEGOVRD_MASK32 | OPAF_PRE_SEGOVRD_MASK64)

struct OP_INFO
{
	BYTE		_class;
	OP_IID		_opId;
	OPRND_TYPE	_or1, _or2;
	OP_ATTRS	_flags;

	OP_INFO()
	{
		_class = 0, _opId = OI_UNKNOWN, _or1 = _or2 = OT_NONE, _flags = 0;
	}
	OP_INFO(BYTE cls, OP_IID id, OPRND_TYPE d, OPRND_TYPE s, OP_ATTRS flags)
	{
		_class = cls, _opId = id, _or1 = d, _or2 = s, _flags = flags;
	}
};
typedef OP_INFO* POP_INFO;


typedef BYTE OP_ATTREX;
/* Extended flags for VEX: */
/* Indicates that the instruction might have VEX.L encoded. */
#define OPAF_VEX_L				 (1)
/* Indicates that the instruction might have VEX.W encoded. */
#define OPAF_VEX_W				 (1 << 1)
/* Indicates that the mnemonic of the instruction is based on the VEX.W bit. */
#define OPAF_MNEMONIC_VEXW_BASED (1 << 2)
/* Indicates that the mnemonic of the instruction is based on the VEX.L bit. */
#define OPAF_MNEMONIC_VEXL_BASED (1 << 3)
/* Forces the instruction to be encoded with VEX.L, otherwise it's undefined. */
#define OPAF_FORCE_VEXL			 (1 << 4)
/*
* Indicates that the instruction is based on the MOD field of the ModRM byte.
* (MOD==11: got the right instruction, else skip +4 in prefixed table for the correct instruction).
*/
//#define OPAF_MODRR_BASED		(1 << 5)
/* Indicates that the instruction doesn't use the VVVV field of the VEX prefix, if it does then it's undecodable. */
#define OPAF_VEX_V_UNUSED		(1 << 6)

struct OP_INFOEX : OP_INFO
{
	OPRND_TYPE	_or3, _or4;
	OP_ATTREX	_flagEx;
	OP_IID		_opId2, _opId3;

	OP_INFOEX() : OP_INFO()
	{
		_or3 = _or4 = OT_NONE, _flagEx = 0;
		_opId2 = _opId3 = OI_UNKNOWN;
	}
	OP_INFOEX(BYTE cls, OP_IID id, OPRND_TYPE d, OPRND_TYPE s, OP_ATTRS flags,
		OPRND_TYPE r3, OPRND_TYPE r4, OP_ATTREX flagEx, OP_IID id2, OP_IID id3)
		: OP_INFO(cls, id, d, s, flags)
	{
		_or3 = r3, _or4 = r4, _flagEx = flagEx;
		_opId2 = id2, _opId3 = id3;
	}
};
typedef OP_INFOEX* POP_INFOEX;

#define FLAG_SET_OPSIZE(di, size) ((di->_flags) |= (((size) & 3) << 8))
#define FLAG_SET_ADDRSIZE(di, size) ((di->_flags) |= (((size) & 3) << 10))
#define FLAG_GET_OPSIZE(flags) (((flags) >> 8) & 3)
#define FLAG_GET_ADDRSIZE(flags) (((flags) >> 10) & 3)
/* To get the LOCK/REPNZ/REP prefixes. */
#define FLAG_GET_PREFIX(flags) ((flags) & 7)
/* Indicates whether the instruction is privileged. */
#define FLAG_GET_PRIVILEGED(flags) (((flags) & FLAG_PRIVILEGED_INSTRUCTION) != 0)

/*
* Macros to extract segment registers from 'segment':
*/
#define SEGR_DEFAULT		 0x80
#define SEGR_SET(di, seg)	 ((di->_segment) |= seg)
#define SEGR_GET(seg)		 (((seg) == REGI_NONE) ? REGI_NONE : ((seg) & 0x7f))
#define SEGR_IS_DEFAULT(seg) (((seg) & SEGR_DEFAULT) == SEGR_DEFAULT)


/* Indicates the instruction belongs to the General Integer set. */
#define ISC_INTEGER	 1
/* Indicates the instruction belongs to the 387 FPU set. */
#define ISC_FPU		 2
/* Indicates the instruction belongs to the P6 set. */
#define ISC_P6		 3
/* Indicates the instruction belongs to the MMX set. */
#define ISC_MMX		 4
/* Indicates the instruction belongs to the SSE set. */
#define ISC_SSE		 5
/* Indicates the instruction belongs to the SSE2 set. */
#define ISC_SSE2	 6
/* Indicates the instruction belongs to the SSE3 set. */
#define ISC_SSE3	 7
/* Indicates the instruction belongs to the SSSE3 set. */
#define ISC_SSSE3	 8
/* Indicates the instruction belongs to the SSE4.1 set. */
#define ISC_SSE4_1	 9
/* Indicates the instruction belongs to the SSE4.2 set. */
#define ISC_SSE4_2	 10
/* Indicates the instruction belongs to the AMD's SSE4.A set. */
#define ISC_SSE4_A	 11
/* Indicates the instruction belongs to the 3DNow! set. */
#define ISC_3DNOW	 12
/* Indicates the instruction belongs to the 3DNow! Extensions set. */
#define ISC_3DNOWEXT 13
/* Indicates the instruction belongs to the VMX (Intel) set. */
#define ISC_VMX		 14
/* Indicates the instruction belongs to the SVM (AMD) set. */
#define ISC_SVM		 15
/* Indicates the instruction belongs to the AVX (Intel) set. */
#define ISC_AVX		 16
/* Indicates the instruction belongs to the FMA (Intel) set. */
#define ISC_FMA		 17
/* Indicates the instruction belongs to the AES/AVX (Intel) set. */
#define ISC_AES		 18
/* Indicates the instruction belongs to the CLMUL (Intel) set. */
#define ISC_CLMUL	 19
#define	ISC_AVX2	 20
#define	ISC_BMI		 21


#define GET_MOD_MODRM(modrm) ((BYTE)((modrm >> 6) & 0x3))
#define GET_REG_MODRM(modrm) ((BYTE)((modrm >> 3) & 0x7))
#define GET_RM_MODRM(modrm)	 ((BYTE)(modrm & 0x7))

#define GET_SCALE_SIB(sib)	 ((BYTE)((sib >> 6) & 0x3))
#define GET_INDEX_SIB(sib)	 ((BYTE)((sib >> 3) & 0x7))
#define GET_BASE_SIB(sib)	 ((BYTE)(sib & 0x7))

#endif	//__PEDASM_H__